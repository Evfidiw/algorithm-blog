（如果认为该笔记有帮助，请麻烦点个star！）



## 一、绪论

（听说会考选择题。。。）

1. 术语（**不考**）
    1. **数据**：对客观事物的符号表示，也指所有能**输入**到计算机中并被计算机程序处理的符号的总称。 
    2. **数据元素**：数据的**基本单位**，在计算机程序中通常作为一个整体进行考虑和处理 
    3. **数据对象**：**性质相同**的数据元素的集合，是数据的一个子集
    4. **数据结构**：是相互之间存在一种或多种**特定关系**的数据元素的集合：（1）集合（2）线性结构（3）树形结构（4）图状结构
    5.  **存储结构**（**物理结构**）：数据结构在计算机中的表示（又称映像）
    6. **数据类型**：一个值的集合和定义在这个值集上的一组操作的总称
    7. **抽象数据类型** (Abstract Data Type, ADT)：指一个数学模型以及定义在该模型上的一组操作
    8. **算法**：
        1. 特性：（1）有穷性（2）确定性（3）可行性（4）输入（5）输出
        2. 要求：（1）正确性（2）可读性（3）健壮性（4）效率与低存储量需求
    
2. 数据结构形式定义：二元组 (D, S)

3. （**重点**）算法效率：时间复杂度 & 空间复杂度

    1. 怎么算？（1）看基本操作的重复执行次数（2）看最高的复杂度

        eg1：开了三层循环，T(n) = O(n^3)。还不理解？[ref](https://zhuanlan.zhihu.com/p/50479555)

        eg2：![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-27_02-00-01.png)

    2. 比较：![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-27_02-04-12.png)



## 二、线性表

1. 概念 (from wiki)![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-27_20-27-26.png)

2. 顺序表

    1. 定义：用一组**地址**连续的存储单元依次存储线性表的数据元素![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-27_20-54-44.png)

    2. 特点（帮助理解）：

        1. **连续存储**：数组中的元素在内存中是连续存放的，这意味着数组的每个元素都有一个固定的位置，可以通过索引直接访问
        2. **固定大小**：在创建数组时，需要指定其大小。一旦数组被创建，其大小就固定了，不能动态改变（在某些编程语言中，如Python，数组实际上是动态的，称为列表）
        3. **索引访问**：数组可以通过索引（通常是从0开始的整数）来访问元素。例如，如果有一个包含5个元素的数组，那么元素可以通过索引0到4来访问

    3. 操作：

        ```c
        #define MAXSIZE 100         //顺序表的最大长度
        typedef struct {
            int *elem;	            //存储空间的基地址
            int length;             //当前长度
        } SqList;                   //顺序表的结构类型为SqList
        
        //初始化
        SqList.length = 0;
        
        //能否取值: O(1)
        bool GetElem(SqList L, int i, int &e) {
        	if(i < 1 || i > L.length) return 0;
        	e = L.elem[i - 1]; //elem[i-1] 单元存储第 i 个数据元素
        	return True;
        }
        
        //插入: O(n)
        bool InsertSq(SqList &L, int i, int e){ //i为插入位置，e为插入的值
            // 1.判断插入是否合法
        	if(i<l || i>L.length+l) return 0;
        	if(L.length == MAXSIZE) return 0;
            // 2.从最后一个元素到插入位置的元素，每个元素依次往后移一位
        	for(int j=L.length-1; j>=i-1; j--) {
        		L.elem[j + l] = L.elem[j];
        	}
            // 3.讲新元素插入，表长+1
        	L.elem[i-l] = e;
            L.length++;                          
            return 1;
        }
        
        //删除: O(n)
        bool DesertSq(SqList &L, int i){ //i为删除位置
            // 1.判断删除是否合法
            if((i < l) || (i > L.length)) return 0;
            // 2.被删除元素之后的元素前移
            for(int j=i; j<=L.length-1; j++) {
                L.elem[j-1] = L.elem[j];             
            }
            L.length--;                              
            return 1;
        }
        
        //按值查找: O(n)
        int LocateELem(SqList L, ElemType e) {
            // 在顺序表L中查找值为e的数据元素，返回其序号
        	for(int i=O; i < L.length; i++) {
        		if (L.elem[i)==e) return i + l; //查找成功,返回序号i+l
        	}
        	return 0; //查找失败
        }
                           
        // 合并（noted，书上（p26）是用指针写的，有点难懂，但如果考试考的是代码填空的话还是得看一眼。。。）
        void mergeArrays(int* array1, int size1, int* array2, int size2, int* mergedArray, int* mergedSize) {
            int i = 0, j = 0, k = 0;
            // 1.先比较谁的数组地址小，再遍历两个数组，将元素复制到新的合并数组中
            while (i < size1 && j < size2) {
                if (array1[i] < array2[j]) {
                    mergedArray[k++] = array1[i++];
                } 
                else {
                    mergedArray[k++] = array2[j++];
                }
            }
            // 如果第一个数组还有剩余元素，复制到合并数组中
            while (i < size1) {
                mergedArray[k++] = array1[i++];
            }
            // 如果第二个数组还有剩余元素，复制到合并数组中
            while (j < size2) {
                mergedArray[k++] = array2[j++];
            }
            // 更新合并数组的大小
            *mergedSize = k;
        }
        ```

3. 链表

    1. 定义：用一组**任意**的存储单元存储线性表的数据结构

        1. 结点：元素有数据信息和后继信息（也就是说一个结点有两种信息，一个存元素一个存后继指针），该元素的映像为结点
        2. 数据域：数据元素信息
        3. 指针域：后继存储位置
        4. 指针/链：指针域存储的信息

    2. 特点（帮助理解）：

        1. **非连续存储**：链表中的元素在内存中不是连续存储的，这意味着每个节点可以位于内存的不同位置
        2. **动态大小**：链表的大小可以在运行时动态改变，不需要预先分配固定大小的内存空间
        3. **插入和删除操作**：链表的插入和删除操作相对简单，只需要改变相应节点的引用指针，不需要移动其他元素

    3. 操作

        ```c
        // 链表节点结构体
        typedef struct Node {
            int data; // 数据部分
            struct Node *next; // 指向下一个节点的指针
        } Node;
        
        // 创建新节点到链表末端
        Node* createNode(int data) {
            Node* newNode = (Node*)malloc(sizeof(Node));
            if (!newNode) {
                fprintf(stderr, "Memory allocation failed!\n");
                exit(EXIT_FAILURE);
            }
            newNode->data = data;
            newNode->next = NULL;
            return newNode;
        }
        
        // 查找: O(n)
        Node* LocateElem(Node* head, int target) {
            Node* current = head;
            while (current != NULL) {
                if (current->data == target) {
                    return current; // 找到目标元素
                }
                current = current->next;
            }
            return NULL; // 没有找到目标元素
        }
        
        // 插入: O(1)
        void insertAtHead(Node** head, int data) {
            Node* newNode = createNode(data);
            newNode->next = *head;
            *head = newNode;
        }
        
        // 删除: O(1)
        void deleteFromHead(Node** head) {
            if (*head == NULL) {
                printf("The list is empty.\n");
                return;
            }
            Node* temp = *head;
            *head = (*head)->next;
            free(temp);
        }
        
        // 合并
        Node* mergeLists(Node* list1, Node* list2) {
            Node dummy = {0};
            Node* tail = &dummy; // 尾指针始终指向新链表的最后一个节点
            while (list1 && list2) {
                if (list1->data < list2->data) {
                    tail->next = list1;
                    list1 = list1->next;
                } 
                else {
                    tail->next = list2;
                    list2 = list2->next;
                }
                tail = tail->next;
            }
            // 如果其中一个链表还有剩余节点，将其直接连接到新链表的末尾
            if (list1) {
                tail->next = list1;
            } 
            else {
                tail->next = list2;
            }
            return dummy.next; // 返回新链表的头节点
        }
        
        // 遍历链表的函数
        void printList(Node* head) {
            Node* current = head;
            while (current != NULL) {
                printf("%d -> ", current->data);
                current = current->next;
            }
            printf("NULL\n");
        }
        ```

    4. 链表的类型：

        1. **单向链表**：像上面即为单向链表的操作，每个节点只有一个指向下一个节点的指针。
        2. **双向链表**：每个节点有两个指针，一个指向下一个节点，另一个指向前一个节点。
        3. **循环链表**：链表的最后一个节点指向第一个节点，形成一个循环。

4. 线性表和链表的区别（帮助理解，注意下**时间复杂度**可能会考）

![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-27_20-51-20.png)

5. 多项式基本操作

    1. 多项式的加法：存储多项式的项系数的同时也存储相应的指数（这样不用存储多项式的非零项）；

    2. 多项式的乘法：
        $$
        \begin{aligned}
        M(x)&=A(x)*B(x)\\
        &=A(x)*[b_1x^{e_1}+b_2x^{e_2}+...+b_nx^{e_n}]\\
        &=\sum_{i=1}^{n}b_iA(x)x^{e_i}
        \end{aligned}
        $$
        

## 三、栈

1. 栈

    1. 定义：仅在表尾插入和删除的线性表，**后进先出**，[ref](https://oi-wiki.org/ds/stack/)

    2. 操作：入栈 & 出栈

        ```c
        int stk[N], tt = 0;// tt表示栈顶
        
        // 入栈
        stk[ ++ tt] = x;
        
        // 出栈
        tt -- ;
        
        // 栈顶的值
        stk[tt];
        
        // 判断栈是否为空
        if (tt > 0) {}
        ```

        - eg1：如果进站的车厢序列为123，则可能得到的出站车厢序列是什么？

            > 123 231 321 213 132

2. 栈的应用

    1. 数制转换：

        - eg1：例如十进制与八进制的转换，手动计算是从低位到高位顺序输出，而栈刚好先进后出（存一个栈代表新的进制，低位先进去，但是输出的时候刚好高位先出来）

            ```C
            void conversion(int N) {  
            	SqStack S;
            	InitStack(S);
            	while (N) {
            		Push(S, N % 8);
            		N /= 8;
            	}
            	while (!StackEmpty(S)) {
            		SElemType e;
            		Pop(S, e);
            		cout << e;
            	}
            }
            ```

    2. 括号匹配的检验：

        - 问题：检查括号的匹配是否正确，( [ ]  ( ) ) 是正确的，[ ( ] ) 则是错误的（即出现右括号时，要和最晚出现的左括号匹配）
        - 怎么做：左括号时入栈，右括号时出栈且检查是否匹配，在开始和结束时栈应该都是空的。

    3. 表达式求值：

        - 问题：不同的运算符优先级不同（例如加法和乘法）
        - 怎么做：
            1. 用两个工作栈（一个称作OPTR用以寄存运算符，一个称作OPND用以寄存操作数或运算结果）
            2. 依次读入表达式中每个字符
                1. 若为操作数则进OPND栈
                2. 若为运算符则进OPTR栈，和栈顶运算比较优先权：栈顶运算符优先级较低则新运算符直接入栈，反之先出栈计算后新运算符再入栈（noted，左括号的优先级最小但不用比较直接进栈，右括号的优先级最大）
        - eg：![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-30_00-56-31.png)

        

## 四、串匹配

1. 串

    1. 串/字符串：由零个或多个字符组成的有限序列
    2. 子串：由任意个连续的字符组成的子序列
    3. 两个串相等：当且仅当两个串的值相等（长度相等，各个对应位置的字符都相等）

2. 简单匹配算法

    - 问题：给定模式串T和子串S，检查S是否为T的子串，若存在则定位其位置

    - 暴力做法：从T的第pos个位置和S第一个位置开始将每个位置进行比较，若相等则继续比较下一个直至全部相等，若不相等则从主串的下个位置和S第一个位置开始从头开始比较，直至匹配成功或失败。

    - 时间复杂度：最好情况下O(n+m)，最坏情况下O(n*m)

    - eg：![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-30_01-27-57.png)

    - code：

        ```c
        int Index_BF(SString S,SString T,int pos) {
        	int i = pos, j = 0;
        	while (i < S.length && j <= T.length) {
        		if (S.ch[i] == T.ch[i]) i++, j++;
        		else i = i-j+2, j = 1;
        	}
        	if (j >= T.length) return i - T.length;
        	else return 0;
        }
        ```

3. KMP算法

    - motivation：由三个缩写分别是"K", “M”, "P"的人发明的算法，帮助算法在**不匹配时跳过尽可能多的字符**来优化暴力算法的时间复杂度。

    - 算法流程：

        1. 创建前缀表（即next数组）：对于每个前缀，找到最长的相等的前缀和后缀

            > eg: 对于 `P = "ABCDABD"`，我们逐步生成部分匹配表：
            >
            > - `A` 的最长公共前后缀长度为 0。
            > - `AB` 的最长公共前后缀长度为 0。
            > - `ABC` 的最长公共前后缀长度为 0。
            > - `ABCD` 的最长公共前后缀长度为 0。
            > - `ABCDA` 的最长公共前后缀长度为 1（`A`）。
            > - `ABCDAB` 的最长公共前后缀长度为 2（`AB`）。
            > - `ABCDABD` 的最长公共前后缀长度为 0。
            >
            > 因此，部分匹配表为：`[0, 0, 0, 0, 1, 2, 0]`

        2. 文本串中匹配：按顺序比较主串T和子串S的字符，如果字符在子串S的下标index处不匹配，得到部分匹配表index-1的值X，在S上跳过X个字符继续匹配

    - eg：（这里下标从0开始，但不影响next数组）
        ![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-30_03-08-38.png)![image](https://github.com/Evfidiw/algorithm-blog/blob/main/code/2_datastrcture/notes/%E6%9C%9F%E6%9C%AB%E8%80%83%E5%85%AB%E8%82%A1%E6%96%87/figs/Snipaste_2023-12-30_03-08-55.png)

    - 利用 nextval 数组改进：

        1. 把next数组换成nextval数组（判断next位置i和i+1是否相同）
            - 如果 `P[i] != P[next[i]]`，则 `nextval[i] = next[i]`
            - 如果 `P[i] == P[next[i]]`，则 `nextval[i] = nextval[next[i]]`
        2. 匹配过程

        > eg: 模式串S='a a a a b', 主串T='a a b a a a a b'
        >
        > 得到next: [0, 1, 2, 3, 4]
        >
        > 1. `nextval[1] = 0`（初始化）。
        > 2. 对于 i = 2：`S[2] = a`，`S[next[2]] = S[1] = a`，因此 `nextval[2] = nextval[next[2]] = nextval[1] = 0`。
        > 3. 对于 i = 3：`S[3] = a`，`S[next[3]] = S[2] = a`，因此 `nextval[3] = nextval[next[3]] = nextval[2] = 0`。
        > 4. 对于 i = 4：`S[4] = a`，`S[next[4]] = S[3] = a`，因此 `nextval[4] = nextval[next[4]] = nextval[3] = 0`。
        > 5. 对于 i = 5：`S[5] = b`，`S[next[5]] = S[4] = a`，因此 `nextval[5] = next[5] = 4`。
        >
        > 得到nextval: [0, 0, 0, 0, 4]
        >
        > `i` 指针用于遍历主串 `T`，初始值为 1。
        >
        > `j` 指针用于遍历模式串 `S`，初始值为 1。
        >
        > 匹配过程：
        >
        > 1. 比较 T[1] 和 S[1]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 2. 比较 T[2] 和 S[2]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 3. 比较 T[3] 和 S[3]:  T[3] 是 'b'，而 S[3] 是 'a'，不匹配。根据 `nextval[3] = 0`，将 `j` 更新为 0。`i` 保持不变。
        > 4. 由于 j=0，i 和 j 都增加1
        > 5. 比较 T[4] 和 S[1]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 6. 比较 T[5] 和 S[2]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 7. 比较 T[6] 和 S[3]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 8. 比较 T[7] 和 S[4]:  都是 'a'，所以 `i` 和 `j` 都增加 1。
        > 9. 比较 T[8] 和 S[5]:  都是 'b'，所以 `i` 和 `j` 都增加 1。
        >
        > 注意，这里按课本的写法，下标是从1开始（如果从0开始，i和j的初始值设为0）
        >
        > **更要注意的是**，跳过X个字符，利用next数组是不匹配处的前一个字符作为索引，利用nextval数组是不匹配处作为索引

        

## 六、树





## 七、图





## 九、查找





## 十、排序

